pragma solidity 0.5.1;

contract EscrowBaseContract {

    enum State {AWAITING_PAYMENT, AWAITING_DELIVERY, COMPLETE}

    //State currentState;
    State constant default_value  = State.AWAITING_PAYMENT;
    //address buyer;
    struct Order { 
        address buyer;
        uint256 deposit;
        State currentState;
        uint32 OrderTime;
    }
    
    address payable constant seller = 0x0667FA2A9dDF39d6921373FFA82E4a48C31b2a97;
    uint256 OrderCount;
    mapping(uint => Order) public order_list;
    modifier onlySeller(){require(msg.sender == seller); _;}
    //modifier inState(State expectedState, uint id){require(order_list[id].currentState == expectedState); _;}
    
    // Сделал, чтобы возвращало не строку, а состояние State
    
    function CheckState(uint id) public view returns(State currentState) {
        if(order_list[id].currentState == State.AWAITING_PAYMENT)
            return State.AWAITING_PAYMENT;
        if(order_list[id].currentState == State.AWAITING_DELIVERY)
            return State.AWAITING_DELIVERY;
        else return State.COMPLETE;
    }
 
    function deposit(address buyer_ad) public  payable {
        uint256 amount = msg.value;
        OrderCount+=1;
        order_list[OrderCount].buyer = buyer_ad;
        order_list[OrderCount].deposit = order_list[OrderCount].deposit + amount;
        order_list[OrderCount].currentState = State.AWAITING_DELIVERY;
        order_list[OrderCount].OrderTime = uint32(now);
    }

    function delivered(uint256 id) public onlySeller {
        order_list[id].currentState = State.COMPLETE;
        withdraw(id);
    }

    function withdraw(uint256 id) internal onlySeller {
        uint256 payment = order_list[id].deposit;
        order_list[id].deposit = 0;
        seller.transfer(payment);
    }
    
    // Пока что через id, найти способ делать это через авторизацию метамаска 
    // Можно оставить кнопку как отмен заказа, доступный только N времени после самого заказа
    // либо сделать её доступной только через N времени после заказа, если он так и не пришёл
    
    // Сейчас выполняется (должен) второй способ
    
    function CancelOrder(uint256 id) public {
        uint256 payment = order_list[id].deposit;
        if (msg.sender == order_list[id].buyer && now - order_list[id].OrderTime >= 30 days)
            order_list[id].deposit = 0;
            msg.sender.transfer(payment);
    }
    
}
